# practical_object_oriented_design_in_ruby
オブジェクト指向設計実践ガイドの写経

## 1章 オブジェクト指向設計

オブジェクト指向設計とは「依存関係を管理すること」  
変更をラクに安全に行う。  
オブジェクトがお互い位のことを知りすぎてはいけない。  

## 2章 単一責任のクラスを設計する

変更を後からできるようにアプリケーションをモデル化する。  
ドキュメントから名詞を抽出しクラスの候補にする。  

単一責任でない場合、複数の役割を持つことになる。  
変更されやすく影響範囲がでかいクラスになってしまう。  

<クラスを単一責任か見極めるには？>  

* Gearがgear_inchesを持っているのがふさわしいか
* Gearがタイヤのサイズを持っているのがふさわしいか
* クラスを1文で簡潔に説明できるか
 * 「それと」「または」といった語彙が含まれていれば2つ以上の責任を持っている

違和感があれば、単一責任ではない。  

## 3章 依存関係を管理する

適切に 設計されたオブジェクトは単一の責任を持つ。  
そのため、適切にされたオブジェクトは問題を解決するために共同作業を行う必要がある。  

オブジェクトが他のオブジェクトのことを知っている必要がある。  
しかし、知っているという状態は依存関係が生まれているということである。  
依存関係を適切に管理できていないと苦しむことになる。  

依存方向の選択する場合、依存先の要件が変わりやすいか？  
変わりやすければ依存の向きを変えてみる。  

具象より抽象のほうが安定している。  
抽象に依存せよ。  

以下を注意して設計する。  

* 変更されやすさ
* クラスに依存している物の数

クラスは自身より変更の可能性が低いクラスにのみ依存するべき。  

## 4章 柔軟なインターフェースを作る

* オブジェクトが何を知っているか(責任範囲)
* オブジェクトが誰を知っているか(依存関係)
* オブジェクトがどのように会話するのか(インターフェース)

<パブリックインターフェース」と「プライベートインターフェース>  

* パブリックインターフェース
 * クラスの責任を明確に述べる契約書
 * 安定している必要がある
 * メソッドシグネチャは基本的に変更しない

<デメテルの法則 LoD:Law of Demeter>  

デメテルの法則は、オブジェクトを疎結合にするためのコーディング規則の集まり。  
「隣人の隣人に話しかけるな」や「メソッドチェーン禁止」などが該当する。  


以下は、デメテルの法則に違反している。  
パブリックインターフェースへの依存が高い。  

```ruby
customer.bicycle.wheel.tire

bicycle = customer.bicycle
wheel = bicycle.wheel
tire = wheel.tire
```


以下は、デメテルの法則違反といい難い。  
中間オブジェクトはすべて同じ型であるEnumerableを持っている。  

```ruby
hash.keys.sort.join(', ')

# Enumerableを返す
hash.keys
# Enumerableを返す
hash.keys.sort
# Stringを返す
hash.keys.join
```

<デメテルの法則の違反を回避する>  

ラッパーメソッドなどで委譲を行うことでメソッドチェーンを隠蔽できる。  
デメテルの法則に違反している場合、パブリックインターフェースが足りていないオブジェクトがあるサインになる。  

## 5章 ダックタイピングでコストを削減する

ダックタイピングはいかなる特定のクラスとも結びつかないパブリックインターフェースである。  
ダックタイピングの由来は「もしオブジェクトがダック(アヒル)のように鳴き、ダックのように歩くのであれば、そのクラスはダックである」という表現に由来。  

ダックタイピングにより、アプリケーションの柔軟性と変更のしやすさを高めれる。  
ダックタイピングのパブリックインターフェースは契約を表すものである。  

ダックタイピングを用いることにより抽象的になり少し理解力が求められる造りにはなってしまう。  
ただし、拡張する際のコストを抑えることができる。  
ダックタイピングはインターフェースのみ共有し、実装は共有しない。  

ダックタイピングによって型依存の失敗を回避できる。  
ダックタイピングはコードが安全に依存できる抽象を明らかにするもの。  

## 6章 継承によって振る舞いを獲得する

継承とは「メッセージの自動委譲」の仕組みである。  
共通の振る舞いをいくつか持つが、他の面は異なるというような問題を解決してくれる。  

Rubyではオブジェクトが理解できないメッセージを受け取ったときに上のスーパークラスをさかのぼって探していく。  

